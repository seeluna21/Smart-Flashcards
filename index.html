<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Flashcards</title>
    <!-- å¼•å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* * ä¸ºå¡ç‰‡ç¿»è½¬æ·»åŠ æ ·å¼ 
         * 'transform-style' å’Œ 'backface-visibility' æ˜¯å®ç°3Dç¿»è½¬æ•ˆæœçš„å…³é”®
         */
        
        /* å¡ç‰‡å®¹å™¨ */
        #flashcard {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        /* å¡ç‰‡çš„æ­£é¢å’ŒèƒŒé¢ */
        #card-front, #card-back {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden; /* å…¼å®¹ Safari */
            /* ä¿æŒç»å¯¹å®šä½å’Œåœ†è§’ï¼Œä½¿å…¶é‡å  */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 0.5rem; /* 8px */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem; /* 24px */
        }

        /* å¡ç‰‡æ­£é¢ */
        #card-front {
            background-color: #4B5563; /* gray-600 */
        }

        /* å¡ç‰‡èƒŒé¢é»˜è®¤æ—‹è½¬180åº¦ï¼ˆéšè—ï¼‰ */
        #card-back {
            transform: rotateY(180deg);
            background-color: #374151; /* gray-700 */
        }

        /* å½“å¡ç‰‡è¢«ç¿»è½¬æ—¶çš„æ ·å¼ */
        #flashcard.is-flipped {
            transform: rotateY(180deg);
        }

        /* ä¸ºåå‘æ¨¡å¼å¼€å…³æ·»åŠ æ ·å¼ */
        .toggle-label {
            transition: background-color 0.2s ease-in;
        }
        .toggle-checkbox:checked + .toggle-label {
            @apply bg-blue-600;
        }
        .toggle-checkbox:checked + .toggle-label + span {
             transform: translateX(100%);
        }
        /* ä¿®æ­£å¼€å…³åœ¨ Tailwind 3+ ä¸Šçš„ä½ç§» */
        .toggle-checkbox:checked + .toggle-label + span {
             transform: translateX(calc(100% - 0.5rem)); /* 100% - padding */
        }
         /* ç¡®ä¿spanåœ¨labelå†…éƒ¨ç§»åŠ¨ */
        .toggle-label {
            width: 100%;
            display: block;
            position: relative;
        }
        .toggle-label + span {
            left: 0.25rem; /* p-1 */
            top: 0.25rem; /* p-1 */
        }
        
        /* ä¸ºæ¿€æ´»çš„æ ‡ç­¾é¡µæ·»åŠ æ ·å¼ */
        .tab-btn.active {
            @apply bg-blue-600 text-white;
        }

        /* ä¸ºæœç´¢ç»“æœä¸­çš„æŒ‰é’®æ·»åŠ æ ·å¼ */
        .add-from-api-btn {
            @apply mt-2 text-sm bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded text-white font-semibold transition-colors;
        }
        .search-result-item {
            @apply p-3 bg-gray-700 rounded-lg;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center font-sans p-4">

    <main class="w-full max-w-md">
        <h1 class="text-3xl font-bold text-center mb-4 text-blue-400">Smart Flashcards</h1>
        
        <!-- è¯­è¨€é€‰æ‹© å’Œ åå‘æ¨¡å¼ -->
        <div class="grid grid-cols-2 gap-4 mb-4">
            <div>
                <label for="language-select" class="block text-sm font-medium text-gray-400 mb-1">Select Deck</label>
                <select id="language-select" class="w-full p-2 rounded bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 h-10">
                    <!-- JS åŠ¨æ€å¡«å…… -->
                </select>
            </div>
            <div>
                <label for="reverse-toggle" class="block text-sm font-medium text-gray-400 mb-1">Reverse Mode (Def -&gt; Word)</label>
                <div class="relative inline-block w-full h-10 align-middle select-none">
                    <input type="checkbox" id="reverse-toggle" class="toggle-checkbox absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer z-10"/>
                    <label for="reverse-toggle" class="toggle-label block overflow-hidden h-full p-1 rounded-full bg-gray-700 cursor-pointer"></label>
                    <span class="absolute left-1 top-1 w-8 h-8 bg-white rounded-full shadow-md transform transition-transform duration-200 ease-in"></span>
                </div>
            </div>
        </div>


        <!-- æ·»åŠ å•è¯çš„è¡¨å• (å¸¦æ ‡ç­¾é¡µ) -->
        <div id="add-word-container" class="mb-4 bg-gray-800 p-4 rounded-lg shadow-md">
            
            <!-- æ ‡ç­¾é¡µæŒ‰é’® -->
            <div class="flex mb-4 border-b border-gray-700">
                <button id="btn-tab-manual" class="tab-btn active flex-1 py-2 px-4 font-semibold text-gray-400 rounded-t-lg focus:outline-none">
                    Manual Add
                </button>
                <button id="btn-tab-web" class="tab-btn flex-1 py-2 px-4 font-semibold text-gray-400 rounded-t-lg focus:outline-none">
                    Web Add
                </button>
            </div>

            <!-- æ ‡ç­¾é¡µ1ï¼šæ‰‹åŠ¨æ·»åŠ  (åŸè¡¨å•) -->
            <div id="tab-content-manual" class="">
                <h2 class="text-xl font-semibold mb-3 text-center text-blue-300">Add Full Card</h2>
                <div class="space-y-3">
                    <input type="text" id="input-word" placeholder="Enter word (or 'New Deck')" class="w-full p-2 rounded bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <input type="text" id="input-definition" placeholder="Enter definition (or new deck name)" class="w-full p-2 rounded bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="btn-add-word" class="w-full bg-blue-600 hover:bg-blue-700 p-2 rounded-lg font-semibold shadow-lg transform transition-transform hover:scale-105">
                        + Add to Deck
                    </button>
                </div>
            </div>
            
            <!-- æ ‡ç­¾é¡µ2ï¼šä»ç½‘ç»œæ·»åŠ  (ä¿®æ”¹ä¸ºæœç´¢) -->
            <div id="tab-content-web" class="hidden">
                <h2 class="text-xl font-semibold mb-3 text-center text-blue-300">Search Dictionary (English Only)</h2>
                <div class="space-y-3">
                    <input type="text" id="input-web-word" placeholder="Search for an English word..." class="w-full p-2 rounded bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="btn-search-web" class="w-full bg-orange-600 hover:bg-orange-700 p-2 rounded-lg font-semibold shadow-lg transform transition-transform hover:scale-105">
                        Search
                    </button>
                </div>
                <!-- æ–°å¢ï¼šæœç´¢ç»“æœåŒºåŸŸ -->
                <div id="search-results" class="mt-4 space-y-2 max-h-48 overflow-y-auto p-2 bg-gray-900 rounded-md">
                    <!-- JS åŠ¨æ€å¡«å…… -->
                    <p class="text-gray-500 text-center">Enter a word to search.</p>
                </div>
            </div>

            <p id="add-feedback" class="text-green-400 text-sm text-center mt-2 h-4"></p> <!-- ç”¨äºæ˜¾ç¤ºåé¦ˆ -->
        </div>

        <!-- æŸ¥çœ‹æ‰€æœ‰å•è¯æŒ‰é’® -->
        <button id="btn-show-all" class="w-full bg-gray-600 hover:bg-gray-700 p-2 rounded-lg font-semibold shadow-lg text-sm mb-4 transform transition-transform hover:scale-105">
            View All Words
        </button>

        <p id="progress-text" class="text-gray-400 text-center mb-4">Let's start learning!</p>

        <!-- å¡ç‰‡åŒºåŸŸ -->
        <div id="flashcard-container" class="relative w-full h-48 cursor-pointer" title="Click to flip">
            <!-- å®¹å™¨éœ€è¦è®¾ç½® perspective æ¥äº§ç”Ÿ3Dæ•ˆæœ -->
            <div id="flashcard" class="relative w-full h-full">
                <!-- å¡ç‰‡æ­£é¢ -->
                <div id="card-front" class="text-2xl font-semibold break-all">
                    <!-- å•è¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
                <!-- å¡ç‰‡èƒŒé¢ -->
                <div id="card-back" class="text-2xl font-semibold break-all">
                    <!-- å®šä¹‰å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
            </div>
        </div>

        <!-- æ§åˆ¶æŒ‰é’® -->
        <div id="controls" class="mt-6 grid grid-cols-2 gap-4">
            <button id="btn-incorrect" class="bg-red-600 hover:bg-red-700 p-4 rounded-lg text-lg font-semibold shadow-lg transform transition-transform hover:scale-105">
                âŒ Incorrect
            </button>
            <button id="btn-correct" class="bg-green-600 hover:bg-green-700 p-4 rounded-lg text-lg font-semibold shadow-lg transform transition-transform hover:scale-105">
                âœ… I Know It
            </button>
        </div>

        <!-- å®Œæˆ/é‡å¯ è§†å›¾ -->
        <div id="completion-view" class="text-center mt-6 hidden">
            <p class="text-4xl mb-4">ğŸ‰</p>
            <p class="text-2xl font-semibold text-green-400 mb-6">Congratulations, all done!</p>
            <button id="btn-restart" class="bg-blue-500 hover:bg-blue-600 p-4 rounded-lg text-lg font-semibold shadow-lg w-full">
                Restart
            </button>
        </div>
    </main>

    <!-- å•è¯åˆ—è¡¨ Modal -->
    <div id="word-list-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-gray-800 w-full max-w-md p-6 rounded-lg shadow-xl max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-blue-300">Word List</h2>
                <button id="btn-close-modal" class="text-gray-400 hover:text-white text-3xl focus:outline-none">&times;</button>
            </div>
            
            <!-- éœ€è¦å¤ä¹  -->
            <div class="mb-6">
                <h3 class="text-xl font-semibold text-red-400 mb-2">âŒ Needs Review (<span id="review-count">0</span>)</h3>
                <ul id="review-list" class="space-y-2 text-gray-300">
                    <!-- JS åŠ¨æ€å¡«å…… -->
                </ul>
            </div>
            
            <!-- å·²æŒæ¡ -->
            <div>
                <h3 class="text-xl font-semibold text-green-400 mb-2">âœ… Mastered / Not Studied (<span id="mastered-count">0</span>)</h3>
                <ul id="mastered-list" class="space-y-2 text-gray-300">
                    <!-- JS åŠ¨æ€å¡«å…… -->
                </ul>
            </div>
        </div>
    </div>


    <script>
        // --- 1. æ•°æ®å®šä¹‰ ---
        // é»˜è®¤æ•°æ®ï¼Œåªåœ¨ç”¨æˆ·ç¬¬ä¸€æ¬¡åŠ è½½æ—¶ä½¿ç”¨
        const defaultDecks = {
            'English': [
                { word: 'Apple', definition: 'è‹¹æœ' },
                { word: 'Learn', definition: 'å­¦ä¹ ' },
                { word: 'Code', definition: 'ç¼–ç¨‹' },
            ],
            'German': [
                { word: 'Welt', definition: 'ä¸–ç•Œ' },
                { word: 'Sprache', definition: 'è¯­è¨€' },
            ],
            'Korean': [
                { word: 'ì•ˆë…•í•˜ì„¸ìš”', definition: 'ä½ å¥½' },
                { word: 'ê°ì‚¬í•©ë‹ˆë‹¤', definition: 'è°¢è°¢' },
            ],
            'New Deck': [] // å…è®¸ç”¨æˆ·åˆ›å»ºæ–°ç‰Œå †
        };

        // å…¨å±€çš„ç‰Œå †æ•°æ®
        let allDecks = {};

        // --- 2. è·å– DOM å…ƒç´  ---
        const flashcardContainer = document.getElementById('flashcard-container');
        const flashcard = document.getElementById('flashcard');
        const cardFront = document.getElementById('card-front');
        const cardBack = document.getElementById('card-back');
        const progressText = document.getElementById('progress-text');

        const controls = document.getElementById('controls');
        const btnIncorrect = document.getElementById('btn-incorrect');
        const btnCorrect = document.getElementById('btn-correct');
        
        const completionView = document.getElementById('completion-view');
        const btnRestart = document.getElementById('btn-restart');

        // è·å–æ·»åŠ å•è¯è¡¨å•çš„å…ƒç´ 
        const inputWord = document.getElementById('input-word');
        const inputDefinition = document.getElementById('input-definition');
        const btnAddWord = document.getElementById('btn-add-word');
        const addFeedback = document.getElementById('add-feedback');
        
        // æ ‡ç­¾é¡µ å’Œ "ç½‘ç»œæ·»åŠ " è¡¨å•çš„å…ƒç´ 
        const btnTabManual = document.getElementById('btn-tab-manual');
        const btnTabWeb = document.getElementById('btn-tab-web');
        const tabContentManual = document.getElementById('tab-content-manual');
        const tabContentWeb = document.getElementById('tab-content-web');
        const inputWebWord = document.getElementById('input-web-word');
        // ä¿®æ”¹ï¼šæŒ‰é’® ID
        const btnSearchWeb = document.getElementById('btn-search-web');
        // æ–°å¢ï¼šæœç´¢ç»“æœ
        const searchResults = document.getElementById('search-results');

        // Modal å…ƒç´ 
        const btnShowAll = document.getElementById('btn-show-all');
        const wordListModal = document.getElementById('word-list-modal');
        const btnCloseModal = document.getElementById('btn-close-modal');
        const reviewList = document.getElementById('review-list');
        const masteredList = document.getElementById('mastered-list');
        const reviewCount = document.getElementById('review-count');
        const masteredCount = document.getElementById('mastered-count');

        // è¯­è¨€å’Œåå‘æ¨¡å¼ å…ƒç´ 
        const languageSelect = document.getElementById('language-select');
        const reverseToggle = document.getElementById('reverse-toggle');

        // --- 3. çŠ¶æ€å˜é‡ ---
        let currentDeck = []; // å½“å‰å­¦ä¹ çš„ç‰Œå †
        let reviewDeck = [];  // ç­”é”™çš„ç‰Œå †ï¼ˆä¼˜å…ˆå­¦ä¹ ï¼‰
        let currentCard = null;
        let isFlipped = false;
        let totalCards = 0;
        let currentLanguage = ''; // å½“å‰é€‰æ‹©çš„è¯­è¨€
        let isReversed = false; // æ˜¯å¦ä¸ºåå‘æ¨¡å¼

        // --- 4. æ ¸å¿ƒåŠŸèƒ½ ---

        /**
         * åŠ è½½æ‰€æœ‰ç‰Œå †
         */
        function loadDecks() {
            const storedDecks = localStorage.getItem('myFlashcardDecks');
            if (storedDecks) {
                allDecks = JSON.parse(storedDecks);
            } else {
                allDecks = defaultDecks;
            }
            
            // å¡«å……ä¸‹æ‹‰èœå•
            languageSelect.innerHTML = ''; // æ¸…ç©º
            Object.keys(allDecks).forEach(deckName => {
                const option = document.createElement('option');
                option.value = deckName;
                option.textContent = deckName;
                languageSelect.appendChild(option);
            });
            
            // è‡ªåŠ¨é€‰æ‹©ä¸Šä¸€æ¬¡çš„è¯­è¨€ï¼Œæˆ–ç¬¬ä¸€ä¸ª
            currentLanguage = localStorage.getItem('lastLanguage') || Object.keys(allDecks)[0];
            languageSelect.value = currentLanguage;
        }

        /**
         * ä¿å­˜æ‰€æœ‰ç‰Œå †åˆ° localStorage
         */
        function saveDecks() {
            localStorage.setItem('myFlashcardDecks', JSON.stringify(allDecks));
            localStorage.setItem('lastLanguage', currentLanguage);
        }

        /**
         * å¯åŠ¨æˆ–é‡å¯æ¸¸æˆ
         */
        function startGame() {
            // ä» allDecks ä¸­è·å–å½“å‰è¯­è¨€çš„ç‰Œå †
            const currentLanguageDeck = allDecks[currentLanguage] || [];
            totalCards = currentLanguageDeck.length;

            // ä½¿ç”¨ Fisher-Yates ç®—æ³•æ‰“ä¹±ç‰Œå †
            currentDeck = [...currentLanguageDeck];
            for (let i = currentDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentDeck[i], currentDeck[j]] = [currentDeck[j], currentDeck[i]];
            }
            
            reviewDeck = [];
            currentCard = null;
            isFlipped = false;

            // é‡ç½®UI
            controls.classList.remove('hidden');
            completionView.classList.add('hidden');
            if (flashcard.classList.contains('is-flipped')) {
                flashcard.classList.remove('is-flipped');
            }

            drawCard();
        }

        /**
         * ä»ç‰Œå †ä¸­æŠ½ä¸€å¼ å¡
         */
        function drawCard() {
            // 0. ç¿»è½¬å›æ­£é¢
            if (isFlipped) {
                flipCard();
            }

            // 1. ä¼˜å…ˆä» "å¤ä¹ ç‰Œå †" æŠ½å¡
            if (reviewDeck.length > 0) {
                currentCard = reviewDeck.shift(); // ä»å¼€å¤´å–
            } 
            // 2. "å¤ä¹ ç‰Œå †" ç©ºäº†ï¼Œå†ä» "ä¸»ç‰Œå †" æŠ½
            else if (currentDeck.length > 0) {
                currentCard = currentDeck.shift(); // ä»å¼€å¤´å–
            } 
            // 3. ä¸¤ä¸ªç‰Œå †éƒ½ç©ºäº†ï¼Œè¯´æ˜å­¦ä¹ å®Œæˆ
            else {
                showCompletion();
                return;
            }

            // 4. æ›´æ–°å¡ç‰‡å†…å®¹
            setTimeout(() => { // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ï¼Œè®©ç¿»è½¬åŠ¨ç”»æ’­å®Œ
                // æ£€æŸ¥æ˜¯å¦åå‘
                if (isReversed) {
                    cardFront.textContent = currentCard.definition;
                    cardBack.textContent = currentCard.word;
                } else {
                    cardFront.textContent = currentCard.word;
                    cardBack.textContent = currentCard.definition;
                }
                updateProgress();
            }, 150); // 150ms å»¶è¿Ÿ
        }

        /**
         * æ·»åŠ ä¸€ä¸ªå®Œæ•´çš„æ–°å•è¯ (æ‰‹åŠ¨æ¨¡å¼)
         */
        function addNewWord() {
            const word = inputWord.value.trim();
            const definition = inputDefinition.value.trim();

            if (word === '' || definition === '') {
                showFeedback('Word and definition cannot be empty!', 'red');
                return;
            }

            // ç‰¹æ®Šé€»è¾‘ï¼šå¦‚æœè¾“å…¥çš„æ˜¯ "New Deck"ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°ç‰Œå †
            if (word.toLowerCase() === 'new deck' && definition.trim() !== '') {
                const newDeckName = definition.trim();
                if (!allDecks[newDeckName]) {
                    allDecks[newDeckName] = [];
                    saveDecks();
                    loadDecks(); // é‡æ–°åŠ è½½ä¸‹æ‹‰èœå•
                    languageSelect.value = newDeckName; // è‡ªåŠ¨é€‰ä¸­
                    currentLanguage = newDeckName;
                    startGame();
                    showFeedback(`New deck "${newDeckName}" has been created!`, 'green');
                } else {
                    showFeedback('This deck already exists', 'red');
                }
                inputWord.value = '';
                inputDefinition.value = '';
                return;
            }


            const newCard = { word, definition };
            
            // 1. æ·»åŠ åˆ°ä¸»æ•°æ®åˆ—è¡¨ (ç”¨äºé‡å¯)
            if (!allDecks[currentLanguage]) {
                allDecks[currentLanguage] = [];
            }
            allDecks[currentLanguage].push(newCard);
            // 2. æ·»åŠ åˆ°å½“å‰å­¦ä¹ ç‰Œå † (ç«‹å³å­¦ä¹ )
            currentDeck.push(newCard);
            
            // 3. æ›´æ–°æ€»æ•°å’Œè¿›åº¦
            totalCards = allDecks[currentLanguage].length;
            updateProgress();
            
            // 4. ä¿å­˜åˆ° localStorage
            saveDecks();

            // 5. æ¸…ç©ºè¾“å…¥æ¡†å¹¶ç»™ä¸åé¦ˆ
            inputWord.value = '';
            inputDefinition.value = '';
            showFeedback('Word added!', 'green');
        }

        /**
         * ä¿®æ”¹ï¼šä» "ç½‘ç»œæ·»åŠ " å˜ä¸º "è¯å…¸æœç´¢"
         * è¿™æ˜¯ä¸€ä¸ª async å‡½æ•°ï¼Œå› ä¸ºå®ƒéœ€è¦ç­‰å¾… API è¿”å›
         */
        async function searchDictionary() {
            const word = inputWebWord.value.trim();
            if (word === '') {
                showFeedback('Please enter a word to search', 'red');
                return;
            }

            // **å…³é”®ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºè‹±è¯­ç‰Œå †**
            if (currentLanguage.toLowerCase() !== 'english') {
                searchResults.innerHTML = `<p class="text-red-400 text-center">Dictionary search only works for the 'English' deck. Please switch to 'Manual Add' for other languages.</p>`;
                return;
            }

            searchResults.innerHTML = `<p class="text-gray-400 text-center">Searching...</p>`;

            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        searchResults.innerHTML = `<p class="text-red-400 text-center">No definitions found for "${word}".</p>`;
                    } else {
                        searchResults.innerHTML = `<p class="text-red-400 text-center">Error fetching from dictionary.</p>`;
                    }
                    return;
                }

                const data = await response.json();
                
                // æ¸…ç©ºæœç´¢ç»“æœ
                searchResults.innerHTML = '';
                let definitionsFound = 0;

                // API è¿”å›çš„æ•°æ®ç»“æ„å¾ˆå¤æ‚ï¼Œæˆ‘ä»¬éœ€è¦éå†å®ƒ
                data.forEach(entry => {
                    entry.meanings.forEach(meaning => {
                        meaning.definitions.forEach(definition => {
                            definitionsFound++;
                            const definitionText = definition.definition;
                            
                            const li = document.createElement('div');
                            li.className = 'search-result-item';
                            li.innerHTML = `
                                <p>${definitionText}</p>
                                <button class="add-from-api-btn">+ Add this definition</button>
                            `;
                            
                            // ä¸ºè¿™ä¸ªæ–°åˆ›å»ºçš„ "Add" æŒ‰é’®ç»‘å®šäº‹ä»¶
                            li.querySelector('.add-from-api-btn').addEventListener('click', () => {
                                addNewWordFromApi(word, definitionText);
                            });
                            
                            searchResults.appendChild(li);
                        });
                    });
                });

                if (definitionsFound === 0) {
                     searchResults.innerHTML = `<p class="text-red-400 text-center">No definitions found for "${word}".</p>`;
                }

            } catch (error) {
                console.error('Dictionary API error:', error);
                searchResults.innerHTML = `<p class="text-red-400 text-center">Network error. Please try again.</p>`;
            }
        }

        /**
         * æ–°å¢ï¼šä¸€ä¸ªä¸“é—¨çš„å‡½æ•°ï¼Œç”¨äºä» API æ·»åŠ å•è¯
         */
        function addNewWordFromApi(word, definition) {
            // æ£€æŸ¥å•è¯æ˜¯å¦å·²å­˜åœ¨
            if (allDecks[currentLanguage] && allDecks[currentLanguage].some(card => card.word === word && card.definition === definition)) {
                showFeedback('This exact card already exists!', 'red');
                return;
            }
            
            const newCard = { word, definition };
            
            if (!allDecks[currentLanguage]) {
                allDecks[currentLanguage] = [];
            }
            allDecks[currentLanguage].push(newCard);
            currentDeck.push(newCard); // ç«‹å³åŠ å…¥å­¦ä¹ 
            
            totalCards = allDecks[currentLanguage].length;
            updateProgress();
            saveDecks();
            
            showFeedback('Word added from dictionary!', 'green');
        }


        /**
         * æ˜¾ç¤ºåé¦ˆä¿¡æ¯
         */
        function showFeedback(message, color = 'green') {
            addFeedback.textContent = message;
            if (color === 'red') {
                addFeedback.classList.remove('text-green-400');
                addFeedback.classList.add('text-red-400');
            } else {
                addFeedback.classList.remove('text-red-400');
                addFeedback.classList.add('text-green-400');
            }
            setTimeout(() => { 
                addFeedback.textContent = ''; 
                addFeedback.classList.remove('text-red-400');
            }, 2000);
        }

        /**
         * å¤„ç† "è®°é”™äº†"
         */
        function handleIncorrect() {
            if (!currentCard) return; // é˜²æ­¢åœ¨å®Œæˆåç‚¹å‡»
            // æŠŠå½“å‰å¡ç‰‡åŠ å…¥åˆ° "å¤ä¹ ç‰Œå †" çš„æœ«å°¾
            reviewDeck.push(currentCard);
            drawCard();
        }

        /**
         * å¤„ç† "è®¤è¯†"
         */
        function handleCorrect() {
            if (!currentCard) return; // é˜²æ­¢åœ¨å®Œæˆåç‚¹å‡»
            // è¿™å¼ å¡è¢«æŒæ¡äº†ï¼Œç›´æ¥æŠ½ä¸‹ä¸€å¼ 
            drawCard();
        }

        /**
         * ç¿»è½¬å¡ç‰‡
         */
        function flipCard() {
            if (!currentCard) return; // é˜²æ­¢åœ¨å®Œæˆåç‚¹å‡»
            isFlipped = !isFlipped;
            flashcard.classList.toggle('is-flipped');
        }

        /**
         * æ›´æ–°è¿›åº¦æ¡
         */
        function updateProgress() {
            const remaining = currentDeck.length + reviewDeck.length;
            const known = totalCards - remaining;
            progressText.textContent = `[${currentLanguage}] Progress: ${known} / ${totalCards} (Review: ${reviewDeck.length})`;
        }

        /**
         * æ˜¾ç¤ºå®Œæˆç•Œé¢
         */
        function showCompletion() {
            cardFront.textContent = 'ğŸ‰';
            cardBack.textContent = 'ğŸ‰';
            controls.classList.add('hidden');
            completionView.classList.remove('hidden');
            progressText.textContent = 'Great job!';
            currentCard = null; // åœæ­¢å“åº”
        }

        /**
         * æ˜¾ç¤ºå•è¯åˆ—è¡¨ Modal
         */
        function showWordListModal() {
            // 1. æ¸…ç©ºæ—§åˆ—è¡¨
            reviewList.innerHTML = '';
            masteredList.innerHTML = '';

            // è·å–å½“å‰è¯­è¨€çš„ç‰Œå †
            const currentLanguageDeck = allDecks[currentLanguage] || [];

            // 2. åˆ›å»ºä¸€ä¸ª "éœ€è¦å¤ä¹ " å•è¯çš„ Setï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾
            // æˆ‘ä»¬ç”¨ word æœ¬èº«ä½œä¸ºkey
            const reviewWordsSet = new Set(reviewDeck.map(card => card.word));

            // 3. éå†ä¸»ç‰Œå †
            const masteredDeck = [];
            currentLanguageDeck.forEach(card => {
                if (!reviewWordsSet.has(card.word)) {
                    // è¿™ä¸ªè¯ä¸åœ¨å¤ä¹ åˆ—è¡¨é‡Œï¼Œè¯´æ˜ "å·²æŒæ¡" (æˆ–è¿˜æœªå­¦ä¹ )
                    masteredDeck.push(card);
                }
            });

            // 4. å¡«å…… "éœ€è¦å¤ä¹ " åˆ—è¡¨
            reviewCount.textContent = reviewDeck.length;
            if (reviewDeck.length === 0) {
                reviewList.innerHTML = '<li class="text-gray-500">None</li>';
            } else {
                reviewDeck.forEach(card => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="font-semibold break-all">${card.word}:</span> <span class="break-all">${card.definition}</span>`;
                    // åˆ é™¤æŒ‰é’®
                    li.appendChild(createDeleteButton(card, 'review'));
                    reviewList.appendChild(li);
                });
            }
            
            // 5. å¡«å…… "å·²æŒæ¡" åˆ—è¡¨
            masteredCount.textContent = masteredDeck.length;
            if (masteredDeck.length === 0) {
                masteredList.innerHTML = '<li class="text-gray-500">None</li>';
            } else {
                masteredDeck.forEach(card => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="font-semibold break-all">${card.word}:</span> <span class="break-all">${card.definition}</span>`;
                    // åˆ é™¤æŒ‰é’®
                    li.appendChild(createDeleteButton(card, 'mastered'));
                    masteredList.appendChild(li);
                });
            }

            // 6. æ˜¾ç¤º Modal
            wordListModal.classList.remove('hidden');
        }

        /**
         * åˆ›å»ºåˆ é™¤æŒ‰é’®
         */
        function createDeleteButton(cardToDelete, listType) {
            const button = document.createElement('button');
            button.textContent = 'Delete';
            button.className = 'ml-4 bg-red-700 hover:bg-red-800 text-white px-2 py-0.5 rounded text-sm float-right';
            button.onclick = (e) => {
                e.stopPropagation(); // é˜²æ­¢è§¦å‘liçš„äº‹ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
                deleteWord(cardToDelete, listType);
            };
            return button;
        }
        
        /**
         * åˆ é™¤å•è¯
         */
        function deleteWord(cardToDelete, listType) {
            // 1. ä»ä¸»ç‰Œå † allDecks ä¸­åˆ é™¤
            const deck = allDecks[currentLanguage];
            const indexInMain = deck.findIndex(card => card.word === cardToDelete.word && card.definition === cardToDelete.definition);
            if (indexInMain > -1) {
                deck.splice(indexInMain, 1);
            }

            // 2. ä»å½“å‰å¤ä¹ ç‰Œå † reviewDeck ä¸­åˆ é™¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (listType === 'review') {
                const indexInReview = reviewDeck.findIndex(card => card.word === cardToDelete.word && card.definition === cardToDelete.definition);
                if (indexInReview > -1) {
                    reviewDeck.splice(indexInReview, 1);
                }
            }

            // 3. ä»å½“å‰å­¦ä¹ ç‰Œå † currentDeck ä¸­åˆ é™¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const indexInCurrent = currentDeck.findIndex(card => card.word === cardToDelete.word && card.definition === cardToDelete.definition);
            if (indexInCurrent > -1) {
                currentDeck.splice(indexInCurrent, 1);
            }
            
            // 4. å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰å¡ç‰‡ï¼Œåˆ™æŠ½ä¸‹ä¸€å¼ 
            if (currentCard && currentCard.word === cardToDelete.word && currentCard.definition === cardToDelete.definition) {
                drawCard();
            }

            // 5. ä¿å­˜æ›´æ”¹
            saveDecks();
            
            // 6. æ›´æ–°æ€»å¡æ•°å’Œè¿›åº¦
            totalCards = allDecks[currentLanguage].length;
            updateProgress();

            // 7. é‡æ–°æ¸²æŸ“ Modal åˆ—è¡¨
            showWordListModal();
        }


        /**
         * éšè—å•è¯åˆ—è¡¨ Modal
         */
        function hideWordListModal() {
            wordListModal.classList.add('hidden');
        }

        // --- 5. ç»‘å®šäº‹ä»¶ç›‘å¬ ---
        flashcardContainer.addEventListener('click', flipCard);
        btnIncorrect.addEventListener('click', handleIncorrect);
        btnCorrect.addEventListener('click', handleCorrect);
        btnRestart.addEventListener('click', startGame);
        
        // ç»‘å®šä¸¤ä¸ªæ·»åŠ æŒ‰é’®
        btnAddWord.addEventListener('click', addNewWord);
        // ä¿®æ”¹ï¼šç»‘å®šæœç´¢æŒ‰é’®
        btnSearchWeb.addEventListener('click', searchDictionary);

        // Modal äº‹ä»¶
        btnShowAll.addEventListener('click', showWordListModal);
        btnCloseModal.addEventListener('click', hideWordListModal);
        wordListModal.addEventListener('click', (e) => {
            // ç‚¹å‡» modal èƒŒæ™¯ï¼ˆç°è‰²é®ç½©ï¼‰æ—¶ä¹Ÿå…³é—­
            if (e.target === wordListModal) {
                hideWordListModal();
            }
        });

        // ç›‘å¬è¯­è¨€å’Œåå‘æ¨¡å¼çš„å˜åŒ–
        languageSelect.addEventListener('change', (e) => {
            currentLanguage = e.target.value;
            localStorage.setItem('lastLanguage', currentLanguage); // è®°ä½é€‰æ‹©
            startGame();
        });

        reverseToggle.addEventListener('change', (e) => {
            isReversed = e.target.checked;
            // ç«‹å³ç”¨æ–°æ¨¡å¼é‡æ–°æ˜¾ç¤ºå½“å‰å¡ç‰‡
            if (currentCard) {
                if (isFlipped) {
                    flipCard(); // å…ˆç¿»å›æ­£é¢
                }
                setTimeout(() => {
                    if (isReversed) {
                        cardFront.textContent = currentCard.definition;
                        cardBack.textContent = currentCard.word;
                    } else {
                        cardFront.textContent = currentCard.word;
                        cardBack.textContent = currentCard.definition;
                    }
                }, 150); // ç­‰å¾…ç¿»è½¬åŠ¨ç”»
            }
        });

        // æ ‡ç­¾é¡µåˆ‡æ¢é€»è¾‘
        btnTabManual.addEventListener('click', () => {
            tabContentManual.classList.remove('hidden');
            tabContentWeb.classList.add('hidden');
            btnTabManual.classList.add('active');
            btnTabWeb.classList.remove('active');
        });

        btnTabWeb.addEventListener('click', () => {
            tabContentManual.classList.add('hidden');
            tabContentWeb.classList.remove('hidden');
            btnTabManual.classList.remove('active');
            btnTabWeb.classList.add('active');
        });


        // é¡µé¢åŠ è½½åè‡ªåŠ¨å¼€å§‹
        document.addEventListener('DOMContentLoaded', () => {
            loadDecks();
            startGame();
            // é¢å¤–åŠŸèƒ½ï¼šå…è®¸åˆ›å»ºæ–°ç‰Œå †
            // åœ¨ "å•è¯" æ¡†è¾“å…¥ "New Deck"ï¼Œåœ¨ "è§£é‡Š" æ¡†è¾“å…¥æ–°ç‰Œå †çš„åå­—ï¼Œç„¶åç‚¹å‡»æ·»åŠ 
            inputWord.addEventListener('focus', () => {
                if (inputWord.value === '') {
                    showFeedback('Tip: Type "New Deck" to create a new deck', 'green');
                }
            });
        });
    </script>
</body>
</html>